// src/middleware/validator/middleware.ts
import { getStatusText } from "../../utils/http-status.js";
import { mergeObjects } from "../../utils/object.js";
import { Validator, VBase, VObjectBase } from "../../validator/validator.js";
var validatorMiddleware = (validationFunction, options) => {
  console.warn(`Current Validator Middleware will be changed with "breaking changes" at the ext major release "v3".
  See the migration guide: https://github.com/honojs/hono/blob/main/docs/MIGRATION.md`);
  const v = new Validator();
  const handler = async (c, next) => {
    var _a;
    const resultSet = {
      hasError: false,
      messages: [],
      results: []
    };
    const schema = validationFunction(v, c);
    const validatorList = getValidatorList(schema);
    let data = {};
    for (const [keys, validator] of validatorList) {
      let results;
      try {
        results = await validator.validate(c.req);
      } catch (e) {
        if (e instanceof Error) {
          const result = getErrorResult(e);
          resultSet.hasError = true;
          resultSet.messages = [result.message || ""];
          resultSet.results = [result];
          break;
        } else {
          return c.text(getStatusText(400), 400);
        }
      }
      let isValid = true;
      const value = results[0].value;
      const jsonData = results[0].jsonData;
      for (const result of results) {
        if (!result.isValid) {
          isValid = false;
          resultSet.hasError = true;
          if (result.ruleType === "value" && result.message !== void 0) {
            resultSet.messages.push(result.message);
          }
        }
        resultSet.results.push(result);
      }
      if (!isValid && resultSet.messages.length === 0) {
        resultSet.results.map((r) => {
          if (!r.isValid && r.ruleType === "type" && r.message) {
            resultSet.messages.push(r.message);
          }
        });
      }
      if (isValid) {
        if (jsonData) {
          const dst = data;
          data = mergeObjects(dst, jsonData);
        } else {
          let tmp = data;
          for (let i = 0; i < keys.length - 1; i++) {
            tmp = tmp[_a = keys[i]] || (tmp[_a] = {});
          }
          tmp[keys[keys.length - 1]] = value;
        }
      }
    }
    if (!resultSet.hasError) {
      c.req.valid(data);
    }
    if (options && options.done) {
      const res = options.done(resultSet, c);
      if (res) {
        return res;
      }
    }
    if (resultSet.hasError) {
      return c.text(resultSet.messages.join("\n"), 400);
    }
    await next();
  };
  return handler;
};
function getValidatorList(schema) {
  const map = [];
  for (const [key, value] of Object.entries(schema)) {
    if (value instanceof VObjectBase) {
      const validators = value.getValidators();
      for (const validator of validators) {
        map.push([value.keys, validator]);
      }
    } else if (value instanceof VBase) {
      map.push([[key], value]);
    } else {
      const children = getValidatorList(value);
      for (const [keys, validator] of children) {
        map.push([[key, ...keys], validator]);
      }
    }
  }
  return map;
}
var getErrorResult = (e) => {
  const result = {
    isValid: false,
    message: e.message,
    target: "unknown",
    key: null,
    value: null,
    ruleName: e.message,
    ruleType: "value"
  };
  return result;
};
export {
  validatorMiddleware
};
