// src/hono.ts
import { compose } from "./compose.js";
import { Context } from "./context.js";
import { extendRequestPrototype } from "./request.js";
import { METHOD_NAME_ALL, METHOD_NAME_ALL_LOWERCASE, METHODS } from "./router.js";
import { RegExpRouter } from "./router/reg-exp-router/index.js";
import { SmartRouter } from "./router/smart-router/index.js";
import { StaticRouter } from "./router/static-router/index.js";
import { TrieRouter } from "./router/trie-router/index.js";
import { getPathFromURL, mergePath } from "./utils/url.js";
function defineDynamicClass() {
  return class {
  };
}
var Hono = class extends defineDynamicClass() {
  constructor(init = {}) {
    super();
    this.router = new SmartRouter({
      routers: [new StaticRouter(), new RegExpRouter(), new TrieRouter()]
    });
    this.strict = true;
    this._tempPath = "";
    this.path = "/";
    this.routes = [];
    this.notFoundHandler = (c) => {
      return c.text("404 Not Found", 404);
    };
    this.errorHandler = (err, c) => {
      console.trace(err);
      const message = "Internal Server Error";
      return c.text(message, 500);
    };
    this.handleEvent = (event) => {
      return this.dispatch(event.request, event);
    };
    this.fetch = (request, Environment, executionCtx) => {
      return this.dispatch(request, executionCtx, Environment);
    };
    this.request = async (input, requestInit) => {
      const req = input instanceof Request ? input : new Request(input, requestInit);
      return await this.fetch(req);
    };
    extendRequestPrototype();
    const allMethods = [...METHODS, METHOD_NAME_ALL_LOWERCASE];
    allMethods.map((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.path = args1;
        } else {
          this.addRoute(method, this.path, args1);
        }
        args.map((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, this.path, handler);
          }
        });
        return this;
      };
    });
    Object.assign(this, init);
  }
  route(path, app) {
    this._tempPath = path;
    if (app) {
      app.routes.map((r) => {
        this.addRoute(r.method, r.path, r.handler);
      });
      this._tempPath = "";
    }
    return this;
  }
  use(arg1, ...handlers) {
    if (typeof arg1 === "string") {
      this.path = arg1;
    } else {
      handlers.unshift(arg1);
    }
    handlers.map((handler) => {
      this.addRoute(METHOD_NAME_ALL, this.path, handler);
    });
    return this;
  }
  on(method, path, ...handlers) {
    if (!method)
      return this;
    this.path = path;
    handlers.map((handler) => {
      this.addRoute(method.toUpperCase(), this.path, handler);
    });
    return this;
  }
  onError(handler) {
    this.errorHandler = handler;
    return this;
  }
  notFound(handler) {
    this.notFoundHandler = handler;
    return this;
  }
  showRoutes() {
    const length = 8;
    this.routes.map((route) => {
      console.log(
        `\x1B[32m${route.method}\x1B[0m ${" ".repeat(length - route.method.length)} ${route.path}`
      );
    });
  }
  addRoute(method, path, handler) {
    method = method.toUpperCase();
    if (this._tempPath) {
      path = mergePath(this._tempPath, path);
    }
    this.router.add(method, path, handler);
    const r = { path, method, handler };
    this.routes.push(r);
  }
  matchRoute(method, path) {
    return this.router.match(method, path);
  }
  handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  dispatch(request, eventOrExecutionCtx, env) {
    const path = getPathFromURL(request.url, this.strict);
    const method = request.method;
    const result = this.matchRoute(method, path);
    request.paramData = result?.params;
    const c = new Context(request, env, eventOrExecutionCtx, this.notFoundHandler);
    if (result && result.handlers.length === 1) {
      const handler = result.handlers[0];
      let res;
      try {
        res = handler(c, async () => {
        });
        if (!res)
          return this.notFoundHandler(c);
      } catch (err) {
        return this.handleError(err, c);
      }
      if (res instanceof Response)
        return res;
      return (async () => {
        let awaited;
        try {
          awaited = await res;
          if (!awaited) {
            return this.notFoundHandler(c);
          }
        } catch (err) {
          return this.handleError(err, c);
        }
        return awaited;
      })();
    }
    const handlers = result ? result.handlers : [this.notFoundHandler];
    const composed = compose(handlers, this.notFoundHandler, this.errorHandler);
    return (async () => {
      try {
        const tmp = composed(c);
        const context = tmp instanceof Promise ? await tmp : tmp;
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. You may forget returning Response object or `await next()`"
          );
        }
        return context.res;
      } catch (err) {
        return this.handleError(err, c);
      }
    })();
  }
};
export {
  Hono
};
