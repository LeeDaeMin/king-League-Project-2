"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var hono_exports = {};
__export(hono_exports, {
  Hono: () => Hono
});
module.exports = __toCommonJS(hono_exports);
var import_compose = require("./compose");
var import_context = require("./context");
var import_request = require("./request");
var import_router = require("./router");
var import_reg_exp_router = require("./router/reg-exp-router");
var import_smart_router = require("./router/smart-router");
var import_static_router = require("./router/static-router");
var import_trie_router = require("./router/trie-router");
var import_url = require("./utils/url");
function defineDynamicClass() {
  return class {
  };
}
class Hono extends defineDynamicClass() {
  constructor(init = {}) {
    super();
    this.router = new import_smart_router.SmartRouter({
      routers: [new import_static_router.StaticRouter(), new import_reg_exp_router.RegExpRouter(), new import_trie_router.TrieRouter()]
    });
    this.strict = true;
    this._tempPath = "";
    this.path = "/";
    this.routes = [];
    this.notFoundHandler = (c) => {
      return c.text("404 Not Found", 404);
    };
    this.errorHandler = (err, c) => {
      console.trace(err);
      const message = "Internal Server Error";
      return c.text(message, 500);
    };
    this.handleEvent = (event) => {
      return this.dispatch(event.request, event);
    };
    this.fetch = (request, Environment, executionCtx) => {
      return this.dispatch(request, executionCtx, Environment);
    };
    this.request = async (input, requestInit) => {
      const req = input instanceof Request ? input : new Request(input, requestInit);
      return await this.fetch(req);
    };
    (0, import_request.extendRequestPrototype)();
    const allMethods = [...import_router.METHODS, import_router.METHOD_NAME_ALL_LOWERCASE];
    allMethods.map((method) => {
      this[method] = (args1, ...args) => {
        if (typeof args1 === "string") {
          this.path = args1;
        } else {
          this.addRoute(method, this.path, args1);
        }
        args.map((handler) => {
          if (typeof handler !== "string") {
            this.addRoute(method, this.path, handler);
          }
        });
        return this;
      };
    });
    Object.assign(this, init);
  }
  route(path, app) {
    this._tempPath = path;
    if (app) {
      app.routes.map((r) => {
        this.addRoute(r.method, r.path, r.handler);
      });
      this._tempPath = "";
    }
    return this;
  }
  use(arg1, ...handlers) {
    if (typeof arg1 === "string") {
      this.path = arg1;
    } else {
      handlers.unshift(arg1);
    }
    handlers.map((handler) => {
      this.addRoute(import_router.METHOD_NAME_ALL, this.path, handler);
    });
    return this;
  }
  on(method, path, ...handlers) {
    if (!method)
      return this;
    this.path = path;
    handlers.map((handler) => {
      this.addRoute(method.toUpperCase(), this.path, handler);
    });
    return this;
  }
  onError(handler) {
    this.errorHandler = handler;
    return this;
  }
  notFound(handler) {
    this.notFoundHandler = handler;
    return this;
  }
  showRoutes() {
    const length = 8;
    this.routes.map((route) => {
      console.log(
        `\x1B[32m${route.method}\x1B[0m ${" ".repeat(length - route.method.length)} ${route.path}`
      );
    });
  }
  addRoute(method, path, handler) {
    method = method.toUpperCase();
    if (this._tempPath) {
      path = (0, import_url.mergePath)(this._tempPath, path);
    }
    this.router.add(method, path, handler);
    const r = { path, method, handler };
    this.routes.push(r);
  }
  matchRoute(method, path) {
    return this.router.match(method, path);
  }
  handleError(err, c) {
    if (err instanceof Error) {
      return this.errorHandler(err, c);
    }
    throw err;
  }
  dispatch(request, eventOrExecutionCtx, env) {
    const path = (0, import_url.getPathFromURL)(request.url, this.strict);
    const method = request.method;
    const result = this.matchRoute(method, path);
    request.paramData = result?.params;
    const c = new import_context.Context(request, env, eventOrExecutionCtx, this.notFoundHandler);
    if (result && result.handlers.length === 1) {
      const handler = result.handlers[0];
      let res;
      try {
        res = handler(c, async () => {
        });
        if (!res)
          return this.notFoundHandler(c);
      } catch (err) {
        return this.handleError(err, c);
      }
      if (res instanceof Response)
        return res;
      return (async () => {
        let awaited;
        try {
          awaited = await res;
          if (!awaited) {
            return this.notFoundHandler(c);
          }
        } catch (err) {
          return this.handleError(err, c);
        }
        return awaited;
      })();
    }
    const handlers = result ? result.handlers : [this.notFoundHandler];
    const composed = (0, import_compose.compose)(handlers, this.notFoundHandler, this.errorHandler);
    return (async () => {
      try {
        const tmp = composed(c);
        const context = tmp instanceof Promise ? await tmp : tmp;
        if (!context.finalized) {
          throw new Error(
            "Context is not finalized. You may forget returning Response object or `await next()`"
          );
        }
        return context.res;
      } catch (err) {
        return this.handleError(err, c);
      }
    })();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Hono
});
