"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var validator_exports = {};
__export(validator_exports, {
  VArray: () => VArray,
  VBase: () => VBase,
  VBoolean: () => VBoolean,
  VBooleanArray: () => VBooleanArray,
  VNumber: () => VNumber,
  VNumberArray: () => VNumberArray,
  VObject: () => VObject,
  VObjectBase: () => VObjectBase,
  VString: () => VString,
  VStringArray: () => VStringArray,
  Validator: () => Validator
});
module.exports = __toCommonJS(validator_exports);
var import_json = require("./../utils/json");
var import_rule = require("./rule");
var import_sanitizer = require("./sanitizer");
class VObjectBase {
  constructor(container, key) {
    this.keys = [];
    this._isOptional = false;
    this.getValidators = () => {
      const validators = [];
      const walk = (container, keys, isOptional) => {
        for (const v of Object.values(container)) {
          if (v instanceof VArray || v instanceof VObject) {
            isOptional || (isOptional = v._isOptional);
            walk(v.container, [...keys, ...v.keys], isOptional);
          } else if (v instanceof VBase) {
            if (isOptional)
              v.isOptional();
            v.baseKeys.push(...keys);
            validators.push(v);
          }
        }
      };
      walk(this.container, this.keys, this._isOptional);
      return validators;
    };
    this.container = container;
    if (this instanceof VArray) {
      this.keys.push(key, "[*]");
    } else if (this instanceof VObject) {
      this.keys.push(key);
    }
  }
  isOptional() {
    this._isOptional = true;
    return this;
  }
}
class VObject extends VObjectBase {
  constructor(container, key) {
    super(container, key);
  }
}
class VArray extends VObjectBase {
  constructor(container, key) {
    super(container, key);
    this.type = "array";
  }
}
class Validator {
  constructor(inArray = false) {
    this.inArray = inArray;
    this.query = (key) => new VString({ target: "query", key });
    this.queries = (key) => new VStringArray({ target: "queries", key });
    this.header = (key) => new VString({ target: "header", key });
    this.body = (key) => new VString({ target: "body", key });
    this.json = (key) => {
      if (this.inArray) {
        return new VStringArray({ target: "json", key });
      } else {
        return new VString({ target: "json", key });
      }
    };
    this.array = (path, validatorFn) => {
      const validator = new Validator(true);
      const res = validatorFn(validator);
      const arr = new VArray(res, path);
      return arr;
    };
    this.object = (path, validatorFn) => {
      const validator = new Validator(this.inArray);
      const res = validatorFn(validator);
      const obj = new VObject(res, path);
      return obj;
    };
  }
}
class VBase {
  constructor(options) {
    this.baseKeys = [];
    this._nested = () => this.baseKeys.length ? true : false;
    this.addSanitizer = (sanitizer2) => {
      this.sanitizers.push(sanitizer2);
      return this;
    };
    this.message = (text) => {
      const len = this.rules.length;
      if (len >= 1) {
        this.rules[len - 1].customMessage = text;
      }
      return this;
    };
    this.isRequired = () => {
      return this.addRule("isRequired", (value) => {
        if (value !== void 0 && value !== null && value !== "")
          return true;
        return false;
      });
    };
    this.isOptional = () => {
      this._optional = true;
      return this.addRule("isOptional", () => true);
    };
    this.isEqual = (comparison) => {
      return this.addRule("isEqual", (value) => {
        return value === comparison;
      });
    };
    this.asNumber = () => {
      return new VNumber({ ...this, type: "number" });
    };
    this.asBoolean = () => {
      return new VBoolean({ ...this, type: "boolean" });
    };
    this.validate = async (req) => {
      let value = void 0;
      let jsonData = void 0;
      if (this.target === "query") {
        value = req.query(this.key);
      }
      if (this.target === "queries") {
        value = req.queries(this.key);
      }
      if (this.target === "header") {
        value = req.header(this.key);
      }
      if (this.target === "body") {
        const body = await req.parseBody();
        value = body[this.key];
      }
      if (this.target === "json") {
        if (this._nested()) {
          this.key = `${this.baseKeys.join(".")}.${this.key}`;
        }
        let obj = {};
        try {
          obj = await req.json();
        } catch (e) {
          throw new Error("Malformed JSON in request body");
        }
        const dst = {};
        value = (0, import_json.JSONPathCopy)(obj, dst, this.key);
        if (this._nested())
          jsonData = dst;
      }
      value = this.sanitizeValue(value);
      const results = [];
      let typeRule = this.rules.shift();
      for (const rule2 of this.rules) {
        if (rule2.type === "type") {
          typeRule = rule2;
        } else if (rule2.type === "value") {
          const result = this.validateRule(rule2, value);
          result.jsonData || (result.jsonData = jsonData);
          results.push(result);
        }
      }
      if (typeRule) {
        const typeResult = this.validateRule(typeRule, value);
        typeResult.jsonData || (typeResult.jsonData = jsonData);
        results.unshift(typeResult);
        this.rules.unshift(typeRule);
      }
      return results;
    };
    this.sanitizeValue = (value) => this.sanitizers.reduce((acc, sanitizer2) => sanitizer2(acc), value);
    this.validateType = (value) => {
      if (this.isArray) {
        if (!Array.isArray(value)) {
          return this._optional && typeof value === "undefined";
        }
        for (const val of value) {
          if (typeof val === "undefined" && this._nested()) {
            value.pop();
          }
          for (const val2 of value) {
            if (typeof val2 !== this.type) {
              if (!this._optional || typeof val2 !== "undefined")
                return false;
            }
          }
        }
      } else {
        if (typeof value !== this.type) {
          if (this._optional && (typeof value === "undefined" || Array.isArray(value))) {
          } else {
            return false;
          }
        }
      }
      return true;
    };
    this.validateValue = (func, value) => {
      if (this._optional && typeof value === "undefined")
        return true;
      if (Array.isArray(value)) {
        if (value.length === 0 && !this._optional)
          return false;
        for (const val of value) {
          if (!func(val)) {
            return false;
          }
        }
        return true;
      } else {
        if (!func(value)) {
          return false;
        }
        return true;
      }
    };
    this.getMessage = (opts) => {
      let keyText;
      const valueText = Array.isArray(opts.value) ? `${opts.value.map(
        (val) => val === void 0 ? "undefined" : typeof val === "string" ? `"${val}"` : val
      ).join(", ")}` : opts.value;
      switch (this.target) {
        case "query":
          keyText = `the query parameter "${this.key}"`;
          break;
        case "queries":
          keyText = `the query parameters "${this.key}"`;
          break;
        case "header":
          keyText = `the request header "${this.key}"`;
          break;
        case "body":
          keyText = `the request body "${this.key}"`;
          break;
        case "json":
          keyText = `the JSON body "${this.key}"`;
          break;
      }
      return `Invalid Value [${valueText}]: ${keyText} is invalid - ${opts.ruleName}`;
    };
    this.target = options.target;
    this.key = options.key;
    this.type = options.type || "string";
    this.rules = [
      {
        name: this.getTypeRuleName(),
        type: "type",
        func: this.validateType
      }
    ];
    this.sanitizers = [];
    this._optional = false;
    this.isArray = options.isArray || false;
  }
  addRule(arg, func) {
    if (typeof arg === "string" && func) {
      this.rules.push({ name: arg, func, type: "value" });
    } else if (arg instanceof Function) {
      this.rules.push({ name: arg.name, func: arg, type: "value" });
    }
    return this;
  }
  get(value) {
    const len = this.rules.length;
    if (len > 0) {
      this.rules[this.rules.length - 1].customMessage = value;
    }
    return this;
  }
  getTypeRuleName() {
    const prefix = "should be";
    return this.isArray ? `${prefix} "${this.type}[]"` : `${prefix} "${this.type}"`;
  }
  validateRule(rule2, value) {
    let isValid = false;
    if (this._nested() && this.target != "json") {
      isValid = false;
    } else if (rule2.type === "value") {
      isValid = this.validateValue(rule2.func, value);
    } else if (rule2.type === "type") {
      isValid = this.validateType(value);
    }
    const message = isValid ? void 0 : rule2.customMessage || this.getMessage({ ruleName: rule2.name, value });
    const result = {
      isValid,
      message,
      target: this.target,
      key: this.key,
      value,
      ruleName: rule2.name,
      ruleType: rule2.type
    };
    return result;
  }
}
class VString extends VBase {
  constructor(options) {
    super(options);
    this.asArray = () => {
      return new VStringArray(this);
    };
    this.isEmpty = (options = { ignore_whitespace: false }) => {
      return this.addRule("isEmpty", (value) => import_rule.rule.isEmpty(value, options));
    };
    this.isLength = (options, arg2) => {
      return this.addRule("isLength", (value) => import_rule.rule.isLength(value, options, arg2));
    };
    this.isAlpha = () => {
      return this.addRule("isAlpha", (value) => import_rule.rule.isAlpha(value));
    };
    this.isNumeric = () => {
      return this.addRule("isNumeric", (value) => import_rule.rule.isNumeric(value));
    };
    this.contains = (elem, options = {
      ignoreCase: false,
      minOccurrences: 1
    }) => {
      return this.addRule("contains", (value) => import_rule.rule.contains(value, elem, options));
    };
    this.isIn = (options) => {
      return this.addRule("isIn", (value) => import_rule.rule.isIn(value, options));
    };
    this.match = (regExp) => {
      return this.addRule("match", (value) => import_rule.rule.match(value, regExp));
    };
    this.trim = () => {
      return this.addSanitizer((value) => import_sanitizer.sanitizer.trim(value));
    };
    this.type = "string";
  }
}
class VNumber extends VBase {
  constructor(options) {
    super(options);
    this.asArray = () => {
      return new VNumberArray(this);
    };
    this.isGte = (min) => {
      return this.addRule("isGte", (value) => import_rule.rule.isGte(value, min));
    };
    this.isLte = (min) => {
      return this.addRule("isLte", (value) => import_rule.rule.isLte(value, min));
    };
    this.type = "number";
  }
}
class VBoolean extends VBase {
  constructor(options) {
    super(options);
    this.asArray = () => {
      return new VBooleanArray(this);
    };
    this.isTrue = () => {
      return this.addRule("isTrue", (value) => import_rule.rule.isTrue(value));
    };
    this.isFalse = () => {
      return this.addRule("isFalse", (value) => import_rule.rule.isFalse(value));
    };
    this.type = "boolean";
  }
}
class VNumberArray extends VNumber {
  constructor(options) {
    super(options);
    this.asNumber = () => {
      return new VNumberArray({ ...this, type: "number" });
    };
    this.asBoolean = () => {
      return new VBooleanArray({ ...this, type: "boolean" });
    };
    this.isArray = true;
    this.rules[0].name = this.getTypeRuleName();
  }
}
class VStringArray extends VString {
  constructor(options) {
    super(options);
    this.asNumber = () => {
      return new VNumberArray({ ...this, type: "number" });
    };
    this.asBoolean = () => {
      return new VBooleanArray({ ...this, type: "boolean" });
    };
    this.isArray = true;
    this.rules[0].name = this.getTypeRuleName();
  }
}
class VBooleanArray extends VBoolean {
  constructor(options) {
    super(options);
    this.asNumber = () => {
      return new VNumberArray({ ...this, type: "number" });
    };
    this.asBoolean = () => {
      return new VBooleanArray({ ...this, type: "boolean" });
    };
    this.isArray = true;
    this.rules[0].name = this.getTypeRuleName();
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VArray,
  VBase,
  VBoolean,
  VBooleanArray,
  VNumber,
  VNumberArray,
  VObject,
  VObjectBase,
  VString,
  VStringArray,
  Validator
});
