"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var middleware_exports = {};
__export(middleware_exports, {
  validatorMiddleware: () => validatorMiddleware
});
module.exports = __toCommonJS(middleware_exports);
var import_http_status = require("../../utils/http-status");
var import_object = require("../../utils/object");
var import_validator = require("../../validator/validator");
const validatorMiddleware = (validationFunction, options) => {
  console.warn(`Current Validator Middleware will be changed with "breaking changes" at the ext major release "v3".
  See the migration guide: https://github.com/honojs/hono/blob/main/docs/MIGRATION.md`);
  const v = new import_validator.Validator();
  const handler = async (c, next) => {
    var _a;
    const resultSet = {
      hasError: false,
      messages: [],
      results: []
    };
    const schema = validationFunction(v, c);
    const validatorList = getValidatorList(schema);
    let data = {};
    for (const [keys, validator] of validatorList) {
      let results;
      try {
        results = await validator.validate(c.req);
      } catch (e) {
        if (e instanceof Error) {
          const result = getErrorResult(e);
          resultSet.hasError = true;
          resultSet.messages = [result.message || ""];
          resultSet.results = [result];
          break;
        } else {
          return c.text((0, import_http_status.getStatusText)(400), 400);
        }
      }
      let isValid = true;
      const value = results[0].value;
      const jsonData = results[0].jsonData;
      for (const result of results) {
        if (!result.isValid) {
          isValid = false;
          resultSet.hasError = true;
          if (result.ruleType === "value" && result.message !== void 0) {
            resultSet.messages.push(result.message);
          }
        }
        resultSet.results.push(result);
      }
      if (!isValid && resultSet.messages.length === 0) {
        resultSet.results.map((r) => {
          if (!r.isValid && r.ruleType === "type" && r.message) {
            resultSet.messages.push(r.message);
          }
        });
      }
      if (isValid) {
        if (jsonData) {
          const dst = data;
          data = (0, import_object.mergeObjects)(dst, jsonData);
        } else {
          let tmp = data;
          for (let i = 0; i < keys.length - 1; i++) {
            tmp = tmp[_a = keys[i]] || (tmp[_a] = {});
          }
          tmp[keys[keys.length - 1]] = value;
        }
      }
    }
    if (!resultSet.hasError) {
      c.req.valid(data);
    }
    if (options && options.done) {
      const res = options.done(resultSet, c);
      if (res) {
        return res;
      }
    }
    if (resultSet.hasError) {
      return c.text(resultSet.messages.join("\n"), 400);
    }
    await next();
  };
  return handler;
};
function getValidatorList(schema) {
  const map = [];
  for (const [key, value] of Object.entries(schema)) {
    if (value instanceof import_validator.VObjectBase) {
      const validators = value.getValidators();
      for (const validator of validators) {
        map.push([value.keys, validator]);
      }
    } else if (value instanceof import_validator.VBase) {
      map.push([[key], value]);
    } else {
      const children = getValidatorList(value);
      for (const [keys, validator] of children) {
        map.push([[key, ...keys], validator]);
      }
    }
  }
  return map;
}
const getErrorResult = (e) => {
  const result = {
    isValid: false,
    message: e.message,
    target: "unknown",
    key: null,
    value: null,
    ruleName: e.message,
    ruleType: "value"
  };
  return result;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  validatorMiddleware
});
