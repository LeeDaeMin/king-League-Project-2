"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var encode_exports = {};
__export(encode_exports, {
  arrayBufferToBase64: () => arrayBufferToBase64,
  arrayBufferToBase64URL: () => arrayBufferToBase64URL,
  decodeBase64: () => decodeBase64,
  decodeBase64URL: () => decodeBase64URL,
  encodeBase64: () => encodeBase64,
  encodeBase64URL: () => encodeBase64URL,
  utf8ToUint8Array: () => utf8ToUint8Array
});
module.exports = __toCommonJS(encode_exports);
const encodeBase64 = (str) => {
  if (str === null) {
    throw new TypeError('1st argument of "encodeBase64" should not be null.');
  }
  try {
    const encoder = new TextEncoder();
    const bytes = encoder.encode(str);
    return btoa(String.fromCharCode(...bytes));
  } catch {
  }
  try {
    return Buffer.from(str).toString("base64");
  } catch (e) {
    console.error('If you want to do "encodeBase64", polyfill "buffer" module.');
    throw e;
  }
};
const decodeBase64 = (str) => {
  if (str === null) {
    throw new TypeError('1st argument of "decodeBase64" should not be null.');
  }
  try {
    const text = atob(str);
    const bytes = new Uint8Array(text.split("").map((c) => c.charCodeAt(0)));
    const decoder = new TextDecoder();
    return decoder.decode(bytes);
  } catch {
  }
  try {
    return Buffer.from(str, "base64").toString();
  } catch (e) {
    console.error('If you want to do "decodeBase64", polyfill "buffer" module.');
    throw e;
  }
};
const encodeBase64URL = (str) => {
  return encodeBase64(str).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
const decodeBase64URL = (str) => {
  const pad = (s) => {
    const diff = s.length % 4;
    if (diff === 2) {
      return `${s}==`;
    }
    if (diff === 3) {
      return `${s}=`;
    }
    return s;
  };
  return decodeBase64(pad(str).replace(/-/g, "+").replace("_", "/"));
};
const utf8ToUint8Array = (str) => {
  const encoder = new TextEncoder();
  return encoder.encode(str);
};
const arrayBufferToBase64 = async (buf) => {
  if (typeof btoa === "function") {
    return btoa(String.fromCharCode(...new Uint8Array(buf)));
  }
  try {
    return Buffer.from(String.fromCharCode(...new Uint8Array(buf))).toString("base64");
  } catch (e) {
  }
  return "";
};
const arrayBufferToBase64URL = async (buf) => {
  return (await arrayBufferToBase64(buf)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  arrayBufferToBase64,
  arrayBufferToBase64URL,
  decodeBase64,
  decodeBase64URL,
  encodeBase64,
  encodeBase64URL,
  utf8ToUint8Array
});
