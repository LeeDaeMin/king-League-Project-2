"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var json_exports = {};
__export(json_exports, {
  JSONPathCopy: () => JSONPathCopy
});
module.exports = __toCommonJS(json_exports);
const JSONPathCopyInternal = (src, dst, parts, results) => {
  let srcVal = src;
  let dstVal = dst;
  const length = parts.length;
  for (let i = 0; i < length && srcVal !== void 0 && dstVal; i++) {
    const p = parts[i];
    if (typeof srcVal !== "object") {
      return srcVal;
    }
    if (srcVal === null) {
      return void 0;
    }
    if (p === "*") {
      const restParts = parts.slice(i + 1);
      const restLength = srcVal.length;
      if (restLength === void 0) {
        parts = Object.keys(srcVal);
        for (const p2 of parts) {
          const srcVal2 = srcVal;
          const dst2 = {};
          JSONPathCopyInternal(srcVal2, dst2, [p2], results);
          dstVal[p2] = dst2[p2];
        }
      } else {
        const res = [];
        for (let i2 = 0; i2 < restLength; i2++) {
          if (typeof srcVal[i2] !== "object" || srcVal[i2] === void 0) {
            res.push(srcVal[i2]);
          } else {
            const srcVal2 = srcVal[i2];
            const dst2 = {};
            const res2 = JSONPathCopyInternal(srcVal2, dst2, restParts, results);
            if (res2 === void 0)
              results.push(void 0);
            dstVal[i2] = dst2;
          }
        }
        if (res.length) {
          Object.assign(dstVal, srcVal);
          results.push(...res);
        }
      }
      return results;
    }
    if (typeof srcVal[p] === "object") {
      dstVal[p] || (dstVal[p] = new srcVal[p].constructor());
    } else if (typeof srcVal[p] !== "undefined") {
      dstVal[p] = srcVal[p];
    } else {
      return void 0;
    }
    srcVal = srcVal[p];
    dstVal = dstVal[p];
  }
  if (typeof srcVal === "object" && dstVal) {
    Object.assign(dstVal, srcVal);
  }
  results.push(srcVal);
  return results;
};
const JSONPathCopy = (src, dst, path) => {
  const results = [];
  const parts = path.replace(/\.?\[(.*?)\]/g, ".$1").split(/\./);
  try {
    JSONPathCopyInternal(src, dst, parts, results);
    if (results.length === 0) {
      return void 0;
    } else if (results.length === 1 && !parts.includes("*")) {
      return results[0];
    }
    return results;
  } catch (e) {
    return void 0;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  JSONPathCopy
});
