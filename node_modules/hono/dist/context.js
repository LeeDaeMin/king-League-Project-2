// src/context.ts
import { serialize } from "./utils/cookie.js";
var Context = class {
  constructor(req, env = {}, executionCtx = void 0, notFoundHandler = () => new Response()) {
    this.error = void 0;
    this._status = 200;
    this._pretty = false;
    this._prettySpace = 2;
    this._executionCtx = executionCtx;
    this.req = req;
    this.env = env;
    this.notFoundHandler = notFoundHandler;
    this.finalized = false;
  }
  get event() {
    if (this._executionCtx instanceof FetchEvent) {
      return this._executionCtx;
    } else {
      throw Error("This context has no FetchEvent");
    }
  }
  get executionCtx() {
    if (this._executionCtx) {
      return this._executionCtx;
    } else {
      throw Error("This context has no ExecutionContext");
    }
  }
  get res() {
    return this._res || (this._res = new Response("404 Not Found", { status: 404 }));
  }
  set res(_res) {
    this._res = _res;
    this.finalized = true;
  }
  header(name, value, options) {
    this._headers || (this._headers = {});
    const key = name.toLowerCase();
    let shouldAppend = false;
    if (options && options.append) {
      const vAlreadySet = this._headers[key];
      if (vAlreadySet && vAlreadySet.length) {
        shouldAppend = true;
      }
    }
    if (shouldAppend) {
      this._headers[key].push(value);
    } else {
      this._headers[key] = [value];
    }
    if (this.finalized) {
      if (shouldAppend) {
        this.res.headers.append(name, value);
      } else {
        this.res.headers.set(name, value);
      }
    }
  }
  status(status) {
    this._status = status;
  }
  set(key, value) {
    this._map || (this._map = {});
    this._map[key] = value;
  }
  get(key) {
    if (!this._map) {
      return void 0;
    }
    return this._map[key];
  }
  pretty(prettyJSON, space = 2) {
    this._pretty = prettyJSON;
    this._prettySpace = space;
  }
  newResponse(data, status, headers = {}) {
    return new Response(data, {
      status,
      headers: this._finalizeHeaders(headers)
    });
  }
  _finalizeHeaders(incomingHeaders) {
    const finalizedHeaders = [];
    const headersKv = this._headers || {};
    if (this._res) {
      this._res.headers.forEach((v, k) => {
        headersKv[k] = [v];
      });
    }
    for (const key of Object.keys(incomingHeaders)) {
      const value = incomingHeaders[key];
      if (typeof value === "string") {
        finalizedHeaders.push([key, value]);
      } else {
        for (const v of value) {
          finalizedHeaders.push([key, v]);
        }
      }
      delete headersKv[key];
    }
    for (const key of Object.keys(headersKv)) {
      for (const value of headersKv[key]) {
        const kv = [key, value];
        finalizedHeaders.push(kv);
      }
    }
    return finalizedHeaders;
  }
  body(data, status = this._status, headers = {}) {
    return this.newResponse(data, status, headers);
  }
  text(text, status, headers) {
    if (!headers && !status && !this._res && !this._headers) {
      return new Response(text);
    }
    status || (status = this._status);
    headers || (headers = {});
    headers["content-type"] = "text/plain; charset=UTF-8";
    return this.newResponse(text, status, headers);
  }
  json(object, status = this._status, headers = {}) {
    const body = this._pretty ? JSON.stringify(object, null, this._prettySpace) : JSON.stringify(object);
    headers["content-type"] = "application/json; charset=UTF-8";
    return this.newResponse(body, status, headers);
  }
  html(html, status = this._status, headers = {}) {
    headers["content-type"] = "text/html; charset=UTF-8";
    return this.newResponse(html, status, headers);
  }
  redirect(location, status = 302) {
    return this.newResponse(null, status, {
      Location: location
    });
  }
  cookie(name, value, opt) {
    const cookie = serialize(name, value, opt);
    this.header("set-cookie", cookie, { append: true });
  }
  notFound() {
    return this.notFoundHandler(this);
  }
  get runtime() {
    const global = globalThis;
    if (global?.Deno !== void 0) {
      return "deno";
    }
    if (global?.Bun !== void 0) {
      return "bun";
    }
    if (typeof global?.WebSocketPair === "function") {
      return "cloudflare";
    }
    if (global?.fastly !== void 0) {
      return "fastly";
    }
    if (typeof global?.EdgeRuntime === "string") {
      return "vercel";
    }
    if (global?.process?.release?.name === "node") {
      return "node";
    }
    if (global?.__lagon__ !== void 0) {
      return "lagon";
    }
    return "other";
  }
};
export {
  Context
};
