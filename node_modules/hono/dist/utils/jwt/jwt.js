// src/utils/jwt/jwt.ts
import {
  utf8ToUint8Array,
  encodeBase64URL,
  arrayBufferToBase64URL,
  decodeBase64URL
} from "../../utils/encode.js";
import { AlgorithmTypes } from "./types.js";
import {
  JwtTokenInvalid,
  JwtTokenNotBefore,
  JwtTokenExpired,
  JwtTokenSignatureMismatched,
  JwtAlgorithmNotImplemented
} from "./types.js";
var param = (name) => {
  switch (name.toUpperCase()) {
    case "HS256":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-256"
        }
      };
    case "HS384":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-384"
        }
      };
    case "HS512":
      return {
        name: "HMAC",
        hash: {
          name: "SHA-512"
        }
      };
    default:
      throw new JwtAlgorithmNotImplemented(name);
  }
};
var signing = async (data, secret, alg = AlgorithmTypes.HS256) => {
  if (!crypto.subtle || !crypto.subtle.importKey) {
    throw new Error("`crypto.subtle.importKey` is undefined. JWT auth middleware requires it.");
  }
  const cryptoKey = await crypto.subtle.importKey(
    "raw" /* RAW */,
    utf8ToUint8Array(secret),
    param(alg),
    false,
    ["sign" /* Sign */]
  );
  return await crypto.subtle.sign(param(alg), cryptoKey, utf8ToUint8Array(data));
};
var sign = async (payload, secret, alg = AlgorithmTypes.HS256) => {
  const encodedPayload = await encodeBase64URL(JSON.stringify(payload));
  const encodedHeader = await encodeBase64URL(JSON.stringify({ alg, typ: "JWT" }));
  const partialToken = `${encodedHeader}.${encodedPayload}`;
  const signature = await arrayBufferToBase64URL(await signing(partialToken, secret, alg));
  return `${partialToken}.${signature}`;
};
var verify = async (token, secret, alg = AlgorithmTypes.HS256) => {
  const tokenParts = token.split(".");
  if (tokenParts.length !== 3) {
    throw new JwtTokenInvalid(token);
  }
  const { payload } = decode(token);
  if (payload.nbf && payload.nbf > Math.floor(Date.now() / 1e3)) {
    throw new JwtTokenNotBefore(token);
  }
  if (payload.exp && payload.exp <= Math.floor(Date.now() / 1e3)) {
    throw new JwtTokenExpired(token);
  }
  const signature = await arrayBufferToBase64URL(
    await signing(tokenParts.slice(0, 2).join("."), secret, alg)
  );
  if (signature !== tokenParts[2]) {
    throw new JwtTokenSignatureMismatched(token);
  }
  return true;
};
var decode = (token) => {
  try {
    const [h, p] = token.split(".");
    const header = JSON.parse(decodeBase64URL(h));
    const payload = JSON.parse(decodeBase64URL(p));
    return {
      header,
      payload
    };
  } catch (e) {
    throw new JwtTokenInvalid(token);
  }
};
export {
  decode,
  sign,
  verify
};
