// src/utils/url.ts
var splitPath = (path) => {
  const paths = path.split(/\//);
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
var patternCache = {};
var getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
var getPathFromURL = (url, strict = true) => {
  const queryIndex = url.indexOf("?");
  const result = url.substring(url.indexOf("/", 8), queryIndex === -1 ? url.length : queryIndex);
  if (strict === false && result.endsWith("/")) {
    return result.slice(0, -1);
  }
  return result;
};
var getQueryStringFromURL = (url) => {
  const queryIndex = url.indexOf("?");
  const result = queryIndex !== -1 ? url.substring(queryIndex) : "";
  return result;
};
var mergePath = (...paths) => {
  let p = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p.endsWith("/")) {
      p = p.slice(0, -1);
      endsWithSlash = true;
    }
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p = `${p}/`;
    } else if (path !== "/") {
      p = `${p}${path}`;
    }
    if (path === "/" && p === "") {
      p = "/";
    }
  }
  return p;
};
var checkOptionalParameter = (path) => {
  const match = path.match(/(^.+)(\/\:[^\/]+)\?$/);
  if (!match)
    return null;
  const base = match[1];
  const optional = base + match[2];
  return [base, optional];
};
export {
  checkOptionalParameter,
  getPathFromURL,
  getPattern,
  getQueryStringFromURL,
  mergePath,
  splitPath
};
