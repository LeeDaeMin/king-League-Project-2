import type { Context } from './context';
export interface ContextVariableMap {
}
export declare type Bindings = Record<string, any>;
export declare type Variables = Record<string, any>;
export declare type Environment = {
    Bindings: Bindings;
    Variables: Variables;
};
export declare type Handler<P extends string = string, E extends Partial<Environment> = Environment, S = any> = (c: Context<P, E, S>, next: Next) => Response | Promise<Response | undefined | void>;
export declare type MiddlewareHandler<P extends string = string, E extends Partial<Environment> = Environment, S = any> = (c: Context<P, E, S>, next: Next) => Promise<Response | undefined | void>;
export declare type NotFoundHandler<E extends Partial<Environment> = Environment> = (c: Context<string, E>) => Response | Promise<Response>;
export declare type ErrorHandler<E extends Partial<Environment> = Environment> = (err: Error, c: Context<string, E>) => Response;
export declare type Next = () => Promise<void>;
declare type ParamKeyName<NameWithPattern> = NameWithPattern extends `${infer Name}{${infer _Pattern}` ? Name : NameWithPattern;
declare type ParamKey<Component> = Component extends `:${infer NameWithPattern}` ? ParamKeyName<NameWithPattern> : never;
export declare type ParamKeys<Path> = Path extends `${infer Component}/${infer Rest}` ? ParamKey<Component> | ParamKeys<Rest> : ParamKey<Path>;
export interface CustomHandler<P = string, E = Partial<Environment>, S = any> {
    (c: Context<P extends string ? P : string, P extends Partial<Environment> ? P : E extends Partial<Environment> ? E : never, P extends string ? E extends Partial<Environment> ? S : P extends Partial<Environment> ? E : never : P extends Partial<Environment> ? E extends Partial<Environment> ? S : E : P>, next: Next): Response | Promise<Response | undefined | void>;
}
export interface ExecutionContext {
    waitUntil(promise: Promise<void>): void;
    passThroughOnException(): void;
}
export {};
